#include "hash_map.h"

/**
 * @brief Generate hash for the integer key
 * 
 * @param key 
 * @param map_size 
 * @return int 
 */
int hash(int key, int map_size)
{
  return key % map_size;
}

/**
 * @brief Initialize hash map with buckets of size map_size.
 * The has map handles collission by chaining. Initializes each bucket's linked list too.
 * 
 * @param map_size 
 * @return hash_map* 
 */
hash_map *init_map(int map_size)
{
  hash_map *map = (hash_map *)calloc(1, sizeof(hash_map));
  map->map_size = map_size;
  map->buckets = (map_bucket **)calloc(map_size, sizeof(map_bucket *));
  assert(map->buckets != NULL, "hash map bucket space allocated");
  for (int i = 0; i < map_size; i++)
  {
    map->buckets[i] = (map_bucket *)calloc(1, sizeof(map_bucket));
    (map->buckets[i])->head = NULL;
    (map->buckets[i])->capacity = 0;
  }

  return map;
}

/**
 * @brief Returns pointer to list containing all map nodes.
 * Make a shallow copy of each element in hash map so that the map stays intact.
 * 
 * @param map 
 * @return map_node* 
 */
map_node *get_all_map_nodes(hash_map *map)
{
  map_node *dummy = (map_node *)calloc(1, sizeof(map_node));
  dummy->next = NULL;
  map_node *prev = dummy;
  int map_size = map->map_size;
  for (int i = 0; i < map_size; i++)
  {
    map_node *head = map->buckets[i]->head;
    while (head != NULL)
    {
      map_node *copy_head = (map_node *)calloc(1, sizeof(map_node));
      copy_head->data = head->data;
      copy_head->key = head->key;
      prev->next = copy_head;
      prev = prev->next;
      head = head->next;
    }
  }
  prev->next = NULL;

  map_node *res = dummy->next;
  free(dummy);
  dummy = NULL;
  return res;
}

/**
 * @brief Delete list generated by get_all_map_nodes
 * 
 * @param node 
 */
void delete_map_node_list(map_node *node)
{
  map_node *temp = NULL;
  while (node)
  {
    temp = node->next;
    free(node);
    node = temp;
  }
}

/**
 * @brief Find an element in a particular bucket.
 * 
 * @param bucket 
 * @param to_find 
 * @return void* 
 */
void *find_in_bucket(map_bucket *bucket, int to_find)
{
  if (bucket->capacity == 0)
    return NULL;

  map_node *temp = bucket->head;
  void *data = NULL;
  while (temp != NULL)
  {
    if (to_find == temp->key)
    {
      data = temp->data;
      break;
    }
    temp = temp->next;
  }
  return data;
}

/*
  Find an element in the map.
*/
void *find_in_map(hash_map *map, int to_find)
{
  int bucket_idx = hash(to_find, map->map_size);
  return find_in_bucket(map->buckets[bucket_idx], to_find);
}

/**
 * @brief Inserts data on the front of the bucket.
 * 
 * @param bucket 
 * @param key 
 * @param data 
 */
void insert_into_bucket(map_bucket *bucket, int key, void *data)
{
  map_node *node = (map_node *)calloc(1, sizeof(map_node));
  node->key = key;
  node->data = data;
  node->next = bucket->head;
  bucket->head = node;
  bucket->capacity += 1;
}

/**
 * @brief Insert data into the map.
 * 
 * @param map 
 * @param key 
 * @param data 
 */
void insert_into_map(hash_map *map, int key, void *data)
{
  assert(find_in_map(map, key) == NULL, "entry being added doesn't already exist in hash map");

  int bucket_idx = hash(key, map->map_size);
  insert_into_bucket(map->buckets[bucket_idx], key, data);
}

/**
 * @brief Delete data from particular bucket
 * 
 * @param bucket 
 * @param to_delete 
 * @return void* 
 */
void *delete_from_bucket(map_bucket *bucket, int to_delete)
{
  map_node *curr = bucket->head;
  map_node *prev = NULL;
  while (curr && curr->key != to_delete)
  {
    prev = curr;
    curr = curr->next;
  }

  if (!curr)
  {
    assert(false, "node not found in hash map");
    return NULL;
  }
  else
  {
    if (prev == NULL)
    {
      bucket->head = curr->next;
    }
    else
    {
      prev->next = curr->next;
    }
    return curr->data;
    bucket->capacity -= 1;
  }
}

/**
 * @brief Delete key from map.
 * 
 * @param map 
 * @param to_delete 
 * @return void* 
 */
void *delete_from_map(hash_map *map, int to_delete)
{
  assert(find_in_map(map, to_delete) != NULL, "entry to be deleted does not exist in hash map");

  int bucket_idx = hash(to_delete, map->map_size);

  return delete_from_bucket(map->buckets[bucket_idx], to_delete);
}

/**
 * @brief Deallocate a map node.
 * 
 * @param node 
 */
void deallocate_map_node(map_node *node)
{
  if (node->next != NULL)
  {
    deallocate_map_node(node->next);
    node->next = NULL;
  }
  free(node);
  node = NULL;
}

/**
 * @brief Deallocate a particular bucket.
 * 
 * @param bucket 
 */
void deallocate_map_bucket(map_bucket *bucket)
{
  if (bucket->capacity != 0)
  {
    deallocate_map_node(bucket->head);
    bucket->head = NULL;
  }
  free(bucket);
  bucket = NULL;
}

/**
 * @brief Deallocate the complete map.
 * 
 * @param map 
 */
void delete_map(hash_map *map)
{
  for (int i = 0; i < map->map_size; i++)
  {
    deallocate_map_bucket(map->buckets[i]);
    map->buckets[i] = NULL;
  }
  free(map->buckets);
  free(map);
  map = NULL;
}